from CheckList_Generator import generate_checklist_document, generate_customer_info_document
from PyQt5.QtWidgets import (QMainWindow, QWidget, QHBoxLayout, QLabel, QComboBox, 
                             QLineEdit, QGridLayout, QPushButton, QMessageBox, QVBoxLayout, QCheckBox)
from PyQt5.QtCore import QRegExp
from PyQt5.QtGui import QRegExpValidator, QIcon
from PyQt5.QtPrintSupport import QPrinterInfo
from PyQt5.QtMultimedia import QMediaPlayer, QMediaContent
from PyQt5.QtCore import QUrl

import os, platform, win32api, sys, shutil, time

class MyWindow(QMainWindow):
    def __init__(self):
        self.media_player = QMediaPlayer()
        super(MyWindow, self).__init__()
        self.setupWindow()
        self.setup_UI()

    
    def setupWindow(self):
        self.setGeometry(400, 200, 400, 700)
        self.setWindowTitle("Checklist Generator")
        try:
            base_path = sys._MEIPASS  # This will work when running the exe generated by PyInstaller
        except Exception:
            base_path = os.path.abspath(".")  # Default to current directory if not running as an exe
        
        logo_path = os.path.join(base_path, "ssg_logo.png")
    
        self.setWindowIcon(QIcon(logo_path))

    def setup_UI(self):
        self.central_widget = QWidget()
        self.setCentralWidget(self.central_widget)

        self.layout = QGridLayout()
        self.layout.setSpacing(10)
        
        self.device_combo_layout = self.devices()
        self.layout.addLayout(self.device_combo_layout, 0, 0)

        self.central_widget.setLayout(self.layout)

    # This methods creates a combo box that lists all of the devices
    def devices(self):
        combo_layout = QHBoxLayout()

        combo_label = QLabel("Device Type")
        combo_layout.addWidget(combo_label)

        self.device_combo = QComboBox()
        self.device_combo.addItem("Select Device")
        self.device_combo.addItem("LHC/LHG")
        self.device_combo.addItem("LHZ")
        self.device_combo.addItem("PTZ")
        self.device_combo.addItem("HUB")
        self.device_combo.addItem("DM12")
        self.device_combo.addItem("DETH")
        self.device_combo.addItem("UAS")
        self.device_combo.addItem("BLK30")
        self.device_combo.addItem("PCE")
        self.device_combo.addItem("LHD")
        self.device_combo.addItem("USB")
        self.device_combo.addItem("CORE")

        combo_layout.addWidget(self.device_combo)

        # Connect the combo box to the device information handler
        self.device_combo.currentIndexChanged.connect(lambda: self.device_information(self.device_combo.currentText()))
        
        return combo_layout

    # Adds all the buttons needed depending on the device
    def device_information(self, selected_device):
        self.clear_layout(self.layout)  # clears all button except for device_combo

        # If a valid device is selected, show the dynamic content
        if selected_device != "Select Device":
            self.essential_device_information()  # The information that every device will have
            self.device_specific_items(selected_device) # The information specific to each device
            self.setup_generate_button() # Creates the save and (save and print) button
            
    def essential_device_information(self):
        # Create a new QGridLayout for dynamic device information
        dynamic_layout = QGridLayout()
        
        self.customer_input = self.user_input_button("Customer:", "Enter the customers name here.", True, True, 40, False, True, False)
        self.SD_layout, self.SD_checkboxes = self.checkbox_button('SD Size:', ('32GB', '500GB', '1T', 'No SD', 'Not Sure'))
        self.serial_input = self.user_input_button("Serial Number:", "Enter the serial number of the device here.", False, True, 5, False, False, False)
        self.modem_layout, self.modem_checkboxes = self.checkbox_button('Modem Type:', ('TC4NAG', 'TC4WWG', 'No Modem'))
        self.imei_input = self.user_input_button("IMEI:", "IMEI of the device. IMEI gets ignored if No Modem is selected.", False, True, 15, False, False, False)
        self.mid_input = self.user_input_button("MID:", "Enter the last three of the MID here.", True, True, 3, False, False, False)
        self.pi_version_input = self.user_input_button("PI Version:", "Enter the PI version here.", True, True, 15, True, False, True)
        self.compression_type_layout, self.compression_type_checkboxes = self.checkbox_button('Compression Type:', ('OVS', 'VideoSoft', 'EdgeVis', 'DWSpectrum'))
        
        dynamic_layout.addLayout(self.customer_input, 0, 0)
        dynamic_layout.addLayout(self.SD_layout, 1, 0)
        dynamic_layout.addLayout(self.serial_input, 2, 0) 
        dynamic_layout.addLayout(self.modem_layout, 3, 0)
        dynamic_layout.addLayout(self.imei_input, 4, 0)      
        dynamic_layout.addLayout(self.mid_input, 5, 0)
        dynamic_layout.addLayout(self.pi_version_input, 6, 0)
        dynamic_layout.addLayout(self.compression_type_layout, 7, 0)

        # Add the dynamic layout to the main layout
        self.layout.addLayout(dynamic_layout, 1, 0)
    
    # Added info for things specific to each device
    def device_specific_items(self, selected_device):
        dynamic_layout = QGridLayout()
        if selected_device == "LHC/LHG":
            self.testFixer_input = self.user_input_button("Test Fixture S/N:", "Enter the test fixture S/N.", False, True, 5, False, False, False)
            dynamic_layout.addLayout(self.testFixer_input, 0, 0)
            
            self.voltageTester_input = self.user_input_button("Voltage Tester S/N:", "Enter the VT S/N.", False, True, 5, False, False, False)
            dynamic_layout.addLayout(self.voltageTester_input, 1, 0)
            
        elif selected_device == "LHZ" or selected_device == "LHD" or selected_device == "CORE":
            self.testFixer_input = self.user_input_button("Test Fixture S/N:", "Enter the test fixture S/N.", False, True, 5, False, False, False)
            dynamic_layout.addLayout(self.testFixer_input, 0, 0)

            self.voltageTester_input = self.user_input_button("Voltage Tester S/N:", "Enter the VT S/N.", False, True, 5, False, False, False)
            dynamic_layout.addLayout(self.voltageTester_input, 1, 0) 
            
        elif selected_device == "PTZ" or selected_device == "DM12" or selected_device == "UAS":
            self.batteryPack_input = self.user_input_button("Battery Pack:", "Enter the battery pack S/N", False, True, 5, False, False, False)
            dynamic_layout.addLayout(self.batteryPack_input, 0, 0)
            
        elif selected_device == "HUB" or selected_device == "DETH":
            self.batteryPack_input = self.user_input_button("Battery Pack:", "Enter the battery pack S/N", False, True, 5, False, False, False)
            dynamic_layout.addLayout(self.batteryPack_input, 0, 0)
            
            self.usb_input = self.user_input_button("USB CAM:", "Enter usb cam S/N here", False, True, 5, False, False, False)
            dynamic_layout.addLayout(self.usb_input, 1, 0)
            
         # elif selected_device == "BLK30":
            # Don't need any yet
            
        elif selected_device == "PCE":
            self.cameraType_input = self.user_input_button("Camera Model:", "Enter the camera model here.", True, True, 20, True, True, False)
            dynamic_layout.addLayout(self.cameraType_input, 1, 0)
            
            self.cameraSN_input = self.user_input_button("Camera S/N:", "Enter the camera S/N here.", True, True, 30, False, False, False)
            dynamic_layout.addLayout(self.cameraSN_input, 2, 0)
            
            self.cameraUsername_input = self.user_input_button("Camera Username:", "Enter the camera username here.", True, False, 30, False, False, False)
            dynamic_layout.addLayout(self.cameraUsername_input, 3, 0)
            
            self.cameraPassword_input = self.user_input_button("Camera Password:", "Enter the camera password here.", True, True, 30, False, False, False)
            dynamic_layout.addLayout(self.cameraPassword_input, 4, 0)
            
            self.cameraIP_Input = self.user_input_button("Camera IP:", "Enter the camera IP here.", False, True, 15, True, False, False)
            dynamic_layout.addLayout(self.cameraIP_Input, 5, 0)
            
            self.usb_input = self.user_input_button("USB CAM:", "Enter usb cam S/N here", False, True, 5, False, False, False)
            dynamic_layout.addLayout(self.usb_input, 6, 0)
        
        self.layout.addLayout(dynamic_layout, 2, 0)
            
        
    # Shortcut to create a label and a input field for user with character restrictions
    def user_input_button(self, name, desc, letters, numbers, length, dot, space, dash):
        layout = QHBoxLayout()
        
        label = QLabel(name)
        layout.addWidget(label)
        
        user_input = QLineEdit()
        user_input.setPlaceholderText(desc)
        
        limits = ""
        if letters == True:
            limits += "A-Za-z"
        if numbers == True:
            limits += "0-9"
        if dot == True:
            limits += "."
        if space == True:
            limits += " "
        if dash == True:
            limits += r"\-"
            
        if limits or length > 0:
            reg = f"[{limits}]{{1,{length}}}"
            regex = QRegExp(reg)
            validator = QRegExpValidator(regex)
            user_input.setValidator(validator)
        
        layout.addWidget(user_input)
        
        return layout
    
    # Creates checkboxes that only allow user to select one box
    def checkbox_button(self, button_name, options):
        checkbox_layout = QHBoxLayout()

        label = QLabel(button_name)
        checkbox_layout.addWidget(label)

        checkboxes = []
        
        for option in options:
            checkbox = QCheckBox(option)
            checkbox.setProperty("group", id(checkboxes))  # assign group id
            checkbox.stateChanged.connect(self.handle_exclusive_checkbox)
            checkboxes.append(checkbox)
            checkbox_layout.addWidget(checkbox)
        
        return checkbox_layout, checkboxes
    
    # This is for checkbox_button
    def handle_exclusive_checkbox(self, state):
        if state == 2:  # 2 means Checked
            sender = self.sender()
            group_id = sender.property("group")
            # Uncheck only checkboxes with the same group id
            for cb in self.findChildren(QCheckBox):
                if cb is not sender and cb.property("group") == group_id:
                    cb.setChecked(False)
                    
    # Cleans all the buttons whenever a user selects a device type
    def clear_layout(self, layout):
        # Iterate over the layout in reverse order
        for i in reversed(range(layout.count())):
            item = layout.itemAt(i)
            if item is not None:
                widget = item.widget()  # Get the widget if it exists
    
                # Check if the widget is the device_combo_layout or any of its children
                if widget == self.device_combo or widget == self.device_combo_layout.itemAt(0).widget():  # Skip combo and label
                    continue
    
                if widget:  # If it's a widget, delete it
                    widget.deleteLater()
                else:  # If it's another layout, clear it recursively
                    nested_layout = item.layout()
                    if nested_layout:  # If the item is a layout, recursively clear it
                        self.clear_layout(nested_layout)  # Recursively clear the nested layout
                        
                        
    # Creates the printer options, save, and (save and print) buttons
    def setup_generate_button(self):
        printers = QPrinterInfo.availablePrinters() # Grabs all availble printers
        printer_names = [printer.printerName() for printer in printers] # Creates a list of all printers
        
        if not printer_names:
            printer_names = ["No printers found"] 
            
        generate_layout = QHBoxLayout()
        
        printer_label = QLabel("Select Printer")
        generate_layout.addWidget(printer_label)
        
        self.printer_combo = QComboBox()
        self.printer_combo.addItems(printer_names)
        generate_layout.addWidget(self.printer_combo)
        
        self.layout.addLayout(generate_layout, 3, 0)
        
        dynamic_layout = QGridLayout()
        save_button = QPushButton("Save")
        save_button.clicked.connect(self.save_document_only)
        dynamic_layout.addWidget(save_button, 0, 0)
        
        generate_button = QPushButton("Save and Print")
        generate_button.clicked.connect(self.save_and_print)
        dynamic_layout.addWidget(generate_button, 0, 1)
        
        self.layout.addLayout(dynamic_layout, 4, 0)

        
    # Grabs all the inputs from the user, checks them, and then sends the info to generate_document
    def grab_generate_information(self):
        # to make sure old info is cleared if generate is run mutiple times
        hashmap = {}
    
        # Collect all the data from the input fields
        deviceType = self.device_combo.currentText()
        sd = None
        for option in self.SD_checkboxes:
            if option.isChecked():
                sd = option.text()
        if sd == "Not Sure":
            sd = ""
        customer = self.customer_input.itemAt(1).widget().text()
        serial = self.serial_input.itemAt(1).widget().text()
        modem = None
        for option in self.modem_checkboxes:
            if option.isChecked():
                modem = option.text()
        if modem != "No Modem":
            imei = self.imei_input.itemAt(1).widget().text()
        else:
            imei = ""
        mid = self.mid_input.itemAt(1).widget().text()
        pi_version = self.pi_version_input.itemAt(1).widget().text()
        compression = None
        for option in self.compression_type_checkboxes:
            if option.isChecked():
                compression = option.text()
        
        # If there is bad data I dont want it to continue so check all the required data
        badInput = False
        
        if sd == None or modem == None or compression == None:
            badInput = True
        
        if modem != "No Modem" and not self.check_user_input(imei, self.imei_input.itemAt(1).widget() , 15):
            badInput = True
        
        if not self.check_user_input(serial, self.serial_input.itemAt(1).widget() , 5):
            badInput = True
        
        if not self.check_user_input(mid, self.mid_input.itemAt(1).widget(), 3):
            badInput = True
        
        # Alert the user if bad data is found
        if badInput:
            hashmap = {}
            if not sd:
                self.userAlertWindow("Select a SD size!", "Critical")
            if not compression:
                self.userAlertWindow("Select a compression type!", "Critical")
            if not modem:
                self.userAlertWindow("Select a modem type!", 'Critical')
            if sd and compression and modem:
                self.userAlertWindow("Bad data!", "Critical")
            return
        
        # Adds all the settings to a hashmap that is used to generate the document
        hashmap = {
            "deviceType": deviceType, "customer": customer, "serial": serial, "modem": modem, "imei": imei,
            "mid": mid, "pi_version": pi_version, "compression_type": compression, "sd_size": sd #,"ovs_version": ovs_version
            }
        
        if deviceType == "LHC/LHG":
            testFixer = self.testFixer_input.itemAt(1).widget().text()
            voltageTester = self.voltageTester_input.itemAt(1).widget().text()
            hashmap["testFixer"] = testFixer
            hashmap["voltageTester"] = voltageTester
        
        elif deviceType == "LHZ" or deviceType == "LHD" or deviceType == "CORE": 
            testFixer = self.testFixer_input.itemAt(1).widget().text()
            voltageTester = self.voltageTester_input.itemAt(1).widget().text()
            hashmap["testFixer"] = testFixer
            hashmap["voltageTester"] = voltageTester
            
        elif deviceType == "PTZ" or deviceType == "DM12" or deviceType == "UAS":
            batteryPack = self.batteryPack_input.itemAt(1).widget().text()
            hashmap["batteryPack"]= batteryPack
            
        elif deviceType == "HUB" or deviceType == "DETH":
            batteryPack = self.batteryPack_input.itemAt(1).widget().text()
            hashmap["batteryPack"]= batteryPack
            
            usb = self.usb_input.itemAt(1).widget().text()
            hashmap["usb"] = usb
            
        #elif deviceType == "BLK30": #Placeholder if items are required for BLK
        
        elif deviceType == "PCE":
            cameraType = self.cameraType_input.itemAt(1).widget().text()
            cameraSerial = self.cameraSN_input.itemAt(1).widget().text()
            cameraUsername = self.cameraUsername_input.itemAt(1).widget().text()
            cameraPass = self.cameraPassword_input.itemAt(1).widget().text()
            cameraIP = self.cameraIP_Input.itemAt(1).widget().text()
            usb = self.usb_input.itemAt(1).widget().text()
            
            hashmap["cameraType"] = cameraType
            hashmap["cameraSerial"] = cameraSerial
            hashmap["cameraUsername"] = cameraUsername
            hashmap["cameraIP"] = cameraIP
            hashmap["cameraPass"] = cameraPass
            hashmap["usb"] = usb
            
        return hashmap
    
    # changes the color of the text if there is bad data
    def check_user_input(self, text, button, length):
        if len(text) < length:
            button.setStyleSheet("background-color: red;")
            return False
        elif len(text) >= length:
            button.setStyleSheet("background-color: white;")
            return True
    
    def save_document_only(self):
        hashmap = self.grab_generate_information()
        # If hashmap is empty then there is bad data
        if not hashmap:
            return 
        
        # This generates the checklist document
        try:
            checklist_document = generate_checklist_document(hashmap)
        except:
            self.userAlertWindow("Failed to generate checklist document!", "Critical")
            return
        
        # This generates the customer document
        try:
            customer_info_document = generate_customer_info_document(hashmap)
        except:
            self.userAlertWindow("Failed to generate customer document!", "Critical")
            return
        
        # This gets the starting path of the documents depending if its ran as an exe or normal
        try: 
            base_path = sys.MEIPASS
        except:
            base_path = os.getcwd()
        
        checklist_docx_path = os.path.join(base_path,checklist_document)
        customer_docx_path = os.path.join(base_path, customer_info_document)
        
        # This tranfers the checklist document to OneDrive
        try:
            retry_count = self.save(checklist_docx_path, hashmap, "checklist")
            if retry_count >= 10:
                self.userAlertWindow("Failed to save checklist document!", "Critical")
                return
        except:
            self.userAlertWindow("Failed to save checklist document!", "Critical")
            return
        
        # This tranfers the customer document to OneDrive
        try:
            retry_count = self.save(customer_docx_path, hashmap, 'customer')
            if retry_count >= 10:
                self.userAlertWindow("Failed to save customer document!", "Critical")
                return
        except:
            self.userAlertWindow("Failed to save customer document!", "Critical")
            return
        
        self.userAlertWindow("Successfully saved documents!", "Information")
            
    def save_and_print(self):
        hashmap = self.grab_generate_information()
        # If hashmap is empty then there is bad data
        if not hashmap:
            return 
        
        # This generates the checklist document
        try:
            checklist_document = generate_checklist_document(hashmap)
        except:
            self.userAlertWindow("Failed to generate checklist document!", "Critical")
            return
        
        # This generates the document meant for the customer
        try:
            customer_info_document = generate_customer_info_document(hashmap)
        except:
            self.userAlertWindow("Failed to generate customer document!", "Critical")
        
        # This gets the path of the documents
        try: 
            base_path = sys.MEIPASS
        except:
            base_path = os.getcwd()
        
        checklist_docx_path = os.path.join(base_path, checklist_document)
        customer_docx_path = os.path.join(base_path, customer_info_document)
        
        # This sends the checklist document to the printer
        try:
            self.print_document(checklist_docx_path)
            time.sleep(2)
        except:
            self.userAlertWindow("Failed to print checklist!", "Critical")
            return
        
        # This sends the customer document to the printer
        try:
            self.print_document(customer_docx_path)
            time.sleep(2)
        except:
            self.userAlertWindow("Failed to print customer document!", "Critical")
            return
        
        # This tranfers the checklist document to OneDrive
        try:
            retry_count = self.save(checklist_docx_path, hashmap, "checklist")
            if retry_count >= 10:
                self.userAlertWindow("Failed to save checklist document!", "Critical")
                return
        except:
            self.userAlertWindow("Failed to save checklist document!", "Critical")
            return
        
        # This tranfers the customer document to OneDrive
        try:
            retry_count = self.save(customer_docx_path, hashmap, 'customer')
            if retry_count >= 10:
                self.userAlertWindow("Failed to save customer document!", "Critical")
                return
        except:
            self.userAlertWindow("Failed to save customer document!", "Critical")
            return
        
        self.userAlertWindow("Successfully Printed and Saved Documents.", "Information")
        
    def save(self, docx_path, hashmap, document_type):
        username = os.getlogin()
        c_folder_path = fr'C:\Users\{username}\Special Services Group, LLC\SSG Customer Access - Documents\Checklists'
        d_folder_path = r'D:\Special Services Group, LLC\SSG Customer Access - Documents\Checklists'
        
        if os.path.exists(c_folder_path):
            # CustomerPath is the absolute destination path
            customerPath = fr'C:\Users\{username}\Special Services Group, LLC\SSG Customer Access - Documents\Checklists\{hashmap["customer"]}'
            if hashmap["customer"] == "":
                customerPath = fr'C:\Users\{username}\Special Services Group, LLC\SSG Customer Access - Documents\Checklists\NoCustomer'
            
            # If customer does not have a folder then create it
            if not os.path.exists(customerPath):
                os.mkdir(customerPath)
            
            if document_type == "checklist":
                destination_path = os.path.join(customerPath, f'{hashmap["serial"]}.docx')
            else:
                destination_path = os.path.join(customerPath, f'{hashmap["serial"]}_customer.docx')
            # Makes sure there is no duplicate
            if os.path.exists(destination_path):
                os.remove(destination_path)
                        
        elif os.path.exists(d_folder_path):
            # CustomerPath is the absolute destination path
            customerPath = fr'D:\Special Services Group, LLC\SSG Customer Access - Documents\Checklists\{hashmap["customer"]}'
            if hashmap["customer"] == "":
                customerPath = r'D:\Special Services Group, LLC\SSG Customer Access - Documents\Checklists\NoCustomer'
            
            # If customer does not have a folder then create it
            if not os.path.exists(customerPath):
                os.mkdir(customerPath)
                
            if document_type == "checklist":
                destination_path = os.path.join(customerPath, f'{hashmap["serial"]}.docx')
            else:
                destination_path = os.path.join(customerPath, f'{hashmap["serial"]}_customer.docx')
            # Makes sure there is no duplicate
            if os.path.exists(destination_path):
                os.remove(destination_path)
        
        else:
            self.userAlertWindow("OneDrive is probably not connect!", "Critical")
        
        count = 0
        while count <= 10:
            try:
                shutil.move(docx_path, destination_path)
                break
            except:
                count += 1
                time.sleep(1)
        return count
        
    def print_document(self, docx_path):
        selected_printer = self.printer_combo.currentText()
        if platform.system() == "Windows":
            printer_name = selected_printer
            if not printer_name:
                print("No printer selected.")
                return
            
            # Send the file to the selected printer
            win32api.ShellExecute(0, "print", docx_path, f'/d:"{printer_name}"', ".", 0)
            print("Sent print command")
                
    # This creates popups to give user feedback on whether something was successful or failed
    def userAlertWindow(self, text, boxType):
        msg = QMessageBox()
        # Set message box icon and title based on boxType
        if boxType == "Information":
            msg.setIcon(QMessageBox.Information)
            msg.setWindowTitle("Information")
            self.play_alert_sound("leedle.mp3")
        elif boxType == "Critical":
            msg.setIcon(QMessageBox.Critical)
            msg.setWindowTitle("Error")
        
        msg.setText(text)
        msg.setStandardButtons(QMessageBox.Ok)
        
        # Show the message box
        msg.exec_()
    
    # Plays leedle notification sound
    def play_alert_sound(self, filename):
        try:
            base_path = getattr(sys, "_MEIPASS", os.path.abspath("."))
            full_path = os.path.join(base_path, filename)
            url = QUrl.fromLocalFile(full_path)
            self.media_player.setMedia(QMediaContent(url))
            self.media_player.setVolume(100)
            self.media_player.play()
        except Exception as e:
            print(f"Failed to play sound: {e}")
